# 09_Greedy 개념 지도

## 🎯 언제 사용하는가?
- 최적해를 구하는 문제 (최대, 최소, 최적화)
- 매 순간 지역적으로 최선의 선택을 하는 전략
- 선택 후 되돌릴 수 없는 결정
- 정렬 후 순서대로 처리하는 패턴

**대표적인 문제 유형들**:
- 활동 선택: 회의실 배정, 작업 스케줄링
- 자원 배분: 동전 거스름돈, 배낭 문제
- 경로/순서: 최단 경로의 일부, 허프만 코딩
- 구간 문제: 구간 커버, 구간 합치기

## 🧠 사고 과정 (Mental Model)
```
문제 → 최적화 목표 → 그리디 선택 속성 확인 → 정렬 기준 → 구현
```

1. **패턴 인식**: "최대", "최소", "최적" + 지역적 선택으로 전역 최적 가능
2. **핵심 아이디어**: 매순간 최선 = 전체 최선 (그리디 선택 속성)
3. **구현 선택**: 정렬 기준 설정 → 순서대로 그리디 선택

## 🛠️ 핵심 템플릿 코드

### 🔸 활동 선택 패턴 (가장 자주 사용)
```java
// 끝나는 시간 기준으로 정렬
Arrays.sort(activities, (a, b) -> a.end - b.end);

int count = 0, lastEnd = 0;
for (Activity act : activities) {
    if (act.start >= lastEnd) {
        count++;
        lastEnd = act.end;
    }
}
```

### 🔸 자원 배분 패턴 (동전, 배낭)
```java
// 큰 단위부터 사용 (내림차순 정렬)
Arrays.sort(coins, Collections.reverseOrder());

int total = 0;
for (int coin : coins) {
    int use = amount / coin;
    total += use;
    amount %= coin;
}
```

### 🔸 우선순위 기반 선택
```java
PriorityQueue<Task> pq = new PriorityQueue<>((a, b) -> b.priority - a.priority);
pq.addAll(tasks);

while (!pq.isEmpty() && canDoMore()) {
    Task best = pq.poll();
    doTask(best);
}
```

## ⚠️ 함정 & 실수 방지

### 💥 자주 터지는 실수들
1. **그리디가 최적해를 보장하지 않는 경우**:
   - 왜 실수하는가: 지역 최적 ≠ 전역 최적인 문제에 적용
   - 해결 방법: 그리디 선택 속성과 최적 부분 구조 증명 필요
   
2. **잘못된 정렬 기준**:
   - 왜 실수하는가: 직관적이지만 틀린 기준으로 정렬
   - 해결 방법: 반례를 통해 정렬 기준 검증

### 🎯 디버깅 체크리스트
- [ ] 그리디 선택이 항상 최적해를 보장하는가?
- [ ] 정렬 기준이 올바른가? (반례 확인)
- [ ] 선택 후 되돌릴 수 없는 결정인가?
- [ ] 부분 문제들이 독립적인가?
- [ ] 시간 복잡도가 효율적인가?

## 📊 복잡도 분석 가이드

| 구현 방식 | 시간복잡도 | 공간복잡도 | 언제 사용? |
|-----------|------------|------------|------------|
| 정렬 후 그리디 | O(n log n) | O(1) | 순서가 중요한 경우 |
| 우선순위큐 | O(n log n) | O(n) | 동적으로 최적 선택 |
| 단순 그리디 | O(n) | O(1) | 정렬 불필요한 경우 |

## 📋 학습 로드맵

### 🥉 초급 (패턴 익히기)
- [x] [예산](./notes/budget.md) - 자원 배분 기본

### 🥈 중급 (최적화 & 응용)  
- [ ] 회의실 배정 - 활동 선택 문제
- [ ] 동전 거스름돈 - 자원 최적화

### 🥇 고급 (마스터 레벨)
- [ ] 허프만 코딩 - 트리 구조 그리디
- [ ] 다익스트라 알고리즘 - 그래프 그리디

## 🔗 연관 패턴 지도

### 🤝 함께 사용되는 패턴들
- **정렬**: 그리디 선택을 위한 순서 정렬
- **우선순위큐**: 매번 최적 원소 선택
- **투포인터**: 정렬된 상태에서 효율적 탐색
- **DP**: 그리디로 안 되는 경우의 대안

### 🔀 대안 패턴들  
- **동적계획법**: 그리디가 최적해를 보장하지 않을 때
- **백트래킹**: 모든 경우를 탐색해야 할 때
- **분할정복**: 문제를 나누어 해결할 수 있을 때

### 🎯 그리디 vs DP 판별법
```
그리디 가능: 지역 최적 → 전역 최적
DP 필요: 이전 선택이 미래 선택에 영향
```

## 💡 실전 팁 & 경험담

### 🎪 면접에서 자주 나오는 변형
- "회의실 배정" → 끝나는 시간 vs 시작 시간 기준
- "배낭 문제" → Fractional(그리디) vs 0/1(DP) 구분
- "최소 동전" → 특정 동전 시스템에서만 그리디 성립

### 🏆 고수들의 노하우
- 그리디 증명: 교환 논법(Exchange Argument) 활용
- 반례 찾기: 작은 케이스로 그리디 검증
- 정렬 기준: 여러 기준 시도해보고 반례로 검증

### 🤔 이런 경우엔 어떻게?
- Q: 그리디인지 DP인지 애매할 때?
- A: 작은 예시로 그리디 시도 → 반례 찾으면 DP
- Q: 여러 정렬 기준이 가능할 때?
- A: 각각 반례 만들어보고 가장 robust한 기준 선택

## 🚨 그리디 함정 문제들
- **동전 문제**: {1, 3, 4} 동전으로 6 만들기 → 그리디(4+1+1=3개) vs 최적(3+3=2개)
- **배낭 문제**: 0/1 배낭은 그리디 불가, Fractional 배낭만 그리디 가능
- **그래프 색칠**: 정점 순서에 따라 결과 달라짐
