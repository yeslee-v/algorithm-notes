# 19_Math 개념 지도

## 🎯 언제 사용하는가?
- 수학적 공식이나 정리를 활용하는 문제
- 진법 변환, 소수, 약수 등 수론 문제
- 기하학적 계산 (좌표, 거리, 각도)
- 비트 연산, 조합론, 확률 문제

**대표적인 문제 유형들**:
- 수론: 소수 판별, 최대공약수, 약수 개수
- 진법: 2진법, 8진법, 16진법 변환
- 기하: 좌표계산, 거리, 넓이
- 조합: 팩토리얼, 조합, 순열

## 🧠 사고 과정 (Mental Model)
```
문제 → 수학적 패턴 인식 → 공식/정리 적용 → 효율적 구현
```

1. **패턴 인식**: 수학 공식으로 직접 해결 가능한가?
2. **핵심 아이디어**: 브루트포스 → 수학적 최적화
3. **구현 선택**: 라이브러리 vs 직접 구현, 정밀도 고려

## 🛠️ 핵심 템플릿 코드

### 🔸 소수 판별 (에라토스테네스의 체)
```java
boolean[] isPrime = new boolean[n + 1];
Arrays.fill(isPrime, true);
isPrime[0] = isPrime[1] = false;

for (int i = 2; i * i <= n; i++) {
    if (isPrime[i]) {
        for (int j = i * i; j <= n; j += i) {
            isPrime[j] = false;
        }
    }
}
```

### 🔸 최대공약수 (유클리드 호제법)
```java
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
// 최소공배수: lcm = a * b / gcd(a, b)
```

### 🔸 진법 변환
```java
// 10진수 → n진수
String toBase(int num, int base) {
    if (num == 0) return "0";
    StringBuilder sb = new StringBuilder();
    while (num > 0) {
        sb.append(num % base);
        num /= base;
    }
    return sb.reverse().toString();
}
```

### 🔸 약수 개수/합 구하기
```java
// 약수 개수
int countDivisors(int n) {
    int count = 0;
    for (int i = 1; i * i <= n; i++) {
        if (n % i == 0) {
            count += (i * i == n) ? 1 : 2;
        }
    }
    return count;
}
```

## ⚠️ 함정 & 실수 방지

### 💥 자주 터지는 실수들
1. **정수 오버플로우**:
   - 왜 실수하는가: 큰 수 연산에서 int 범위 초과
   - 해결 방법: long 사용하거나 모듈로 연산
   
2. **부동소수점 정밀도**:
   - 왜 실수하는가: Math.pow() 등에서 정밀도 손실
   - 해결 방법: 정수 연산으로 대체하거나 epsilon 비교

### 🎯 디버깅 체크리스트
- [ ] 오버플로우 가능성 확인 (long 사용)
- [ ] 0으로 나누기 예외 처리
- [ ] 음수 입력 처리 (절댓값, 부호)
- [ ] 부동소수점 == 비교 대신 epsilon 사용
- [ ] 모듈로 연산 시 음수 결과 처리

## 📊 복잡도 분석 가이드

| 구현 방식 | 시간복잡도 | 공간복잡도 | 언제 사용? |
|-----------|------------|------------|------------|
| 소수 판별 (단일) | O(√n) | O(1) | 개별 소수 확인 |
| 에라토스테네스 체 | O(n log log n) | O(n) | 범위 내 모든 소수 |
| 유클리드 호제법 | O(log min(a,b)) | O(1) | 최대공약수 |
| 약수 구하기 | O(√n) | O(1) | 약수 개수/합 |

## 📋 학습 로드맵

### 🥉 초급 (패턴 익히기)
- [x] [3진법 뒤집기](./notes/ternary_reverse.md) - 진법 변환
- [x] [약수의 합](./notes/sum_of_divisors.md) - 약수 계산
- [x] [나머지가 1이 되는 수 찾기](./notes/find_remainder_one.md) - 모듈로 연산

### 🥈 중급 (최적화 & 응용)  
- [x] [소수 만들기](./notes/make_prime.md) - 소수 판별
- [x] [약수의 개수와 덧셈](./notes/count_divisors_and_sum.md) - 약수 최적화
- [x] [비밀지도](./notes/secret_map.md) - 비트 연산

### 🥇 고급 (마스터 레벨)
- [ ] 확장 유클리드 호제법 - 베주 항등식
- [ ] 중국인의 나머지 정리 - 모듈로 시스템

## 🔗 연관 패턴 지도

### 🤝 함께 사용되는 패턴들
- **DP**: 피보나치, 조합 계산에서 메모이제이션
- **그리디**: 동전 문제에서 수학적 증명
- **이분탐색**: 제곱근, 거듭제곱 계산
- **해시맵**: 소인수분해 결과 저장

### 🔀 대안 패턴들  
- **브루트포스**: 수학 공식을 모를 때 완전탐색
- **라이브러리**: BigInteger, BigDecimal로 정밀도 해결
- **근사 알고리즘**: 정확한 계산이 너무 복잡할 때

## 💡 실전 팁 & 경험담

### 🎪 면접에서 자주 나오는 변형
- "소수 판별" → 단일 확인 vs 범위 확인 (에라토스테네스)
- "최대공약수" → 재귀 vs 반복문 구현
- "진법 변환" → 문자열 vs 수학적 계산

### 🏆 고수들의 노하우
- 모듈로 연산: `(a + b) % MOD = ((a % MOD) + (b % MOD)) % MOD`
- 거듭제곱: `Math.pow()` 대신 분할정복으로 O(log n)
- 소수: 2, 3 따로 처리 후 6k±1 형태만 확인

### 🤔 이런 경우엔 어떻게?
- Q: 매우 큰 수의 연산은?
- A: BigInteger 사용하거나 모듈로 연산
- Q: 부동소수점 정밀도 문제는?
- A: 정수로 변환하거나 적절한 epsilon 설정

## 🧮 자주 쓰는 수학 공식들

### 기본 공식
- **등차수열 합**: `n * (a + l) / 2` 또는 `n * (2a + (n-1)d) / 2`
- **등비수열 합**: `a * (r^n - 1) / (r - 1)` (r ≠ 1)
- **조합**: `C(n,r) = C(n-1,r-1) + C(n-1,r)`

### 소수 관련
- **소수 정리**: n 이하 소수 개수 ≈ `n / ln(n)`
- **골드바흐 추측**: 4 이상 짝수는 두 소수의 합
- **윌슨 정리**: p가 소수 ⟺ `(p-1)! ≡ -1 (mod p)`
